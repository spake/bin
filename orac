#!/usr/bin/env python2.7

import os
import shutil
import sys
import subprocess
import time

LANGUAGES = ['c', 'c++', 'python']
DEFAULT_LANGUAGE = 'c++'

TIMEOUT = 10

def usage():
    print 'orac automator'
    print 'by spake, https://github.com/spake'
    print
    print 'usage:'
    print '%s <command> <command args> [language]' % sys.argv[0]
    print
    print 'commands:'
    print 'test <name>: runs unit tests using files named <name>in.n and <name>out.n, n >= 0'
    print 'submit <name> <set> <id>: submits a solution to orac'
    print
    print 'language specifies a language to use for submission and testing. accepted languages are %s' % ', '.join(LANGUAGES)
    exit(0)

def usage_assert(condition):
    if not condition:
        usage()

usage_assert(len(sys.argv) > 1)

command = sys.argv[1]
if command == 'test':
    usage_assert(len(sys.argv) >= 3)

    if len(sys.argv) >= 4:
        lang = sys.argv[3]
        usage_assert(lang in LANGUAGES)
    else:
        lang = DEFAULT_LANGUAGE

    name = sys.argv[2]

    if lang == 'c' or lang == 'c++':
        source_filename = '%s.%s' % (name, 'c' if lang == 'c' else 'cpp')
        exec_filename = '%s.o' % name
        compiler = 'gcc' if lang == 'c' else 'g++'
        flags = '-m32 -O2 -lm'
        print '>>> Compiling %s' % source_filename
        result = subprocess.call("%s %s %s -o %s" % (compiler, flags, source_filename, exec_filename), shell=True)
        if result != 0:
            print
            print 'Error during compilation, testing aborted.'
            exit(1)
        exec_command = './%s' % exec_filename
    elif lang == 'python':
        exec_command = 'python %s.py' % name

    print '>>> Running tests'

    n = 0
    successes = 0
    failures = 0
    exec_in = '%sin.txt' % name
    exec_out = '%sout.txt' % name
    while True:
        in_file = '%sin.%d' % (name, n)
        out_file = '%sout.%d' % (name, n)

        if os.path.exists(in_file) and os.path.exists(out_file):
            shutil.copyfile(in_file, exec_in)
            start_time = time.time()
            result = subprocess.call(exec_command, shell=True)
            running_time = time.time() - start_time
            if result != 0:
                status = 'crashed'
                failures += 1
            else:
                exec_contents = open(exec_out, "r").read().strip()
                out_contents = open(out_file, "r").read().strip()
                if exec_contents == out_contents:
                    status = 'correct'
                    successes += 1
                else:
                    status = 'incorrect'
                    failures += 1

            print '#%d: %s (%.3fs)' % (n, status, running_time)

            n += 1
        else:
            break

    if successes+failures == 0:
        print 'No tests found!'
    else:
        print
        print '%d successes, %d failures' % (successes, failures)
        print 'SCORE: %.0f%%' % (successes/float(successes+failures)*100)

elif command == 'submit':
    usage_assert(len(sys.argv) >= 5)

    name, problem_set, problem_id = sys.argv[2:5]

    print 'submit not yet implemented. soz4lyf'
else:
    usage()
